name: Check Benefit Links

on:
  schedule:
    - cron: '0 6 * * 0' # Every Sunday at 6am UTC
  workflow_dispatch:

jobs:
  check-links:
    runs-on: ubuntu-slim
    permissions:
      issues: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Check all benefit links
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const benefits = JSON.parse(fs.readFileSync('benefits.json', 'utf8'));

            const brokenLinks = [];
            const redirectedLinks = [];

            for (const benefit of benefits) {
              console.log('Checking:', benefit.name, '-', benefit.link);

              try {
                // First try HEAD request
                let response = await fetch(benefit.link, {
                  method: 'HEAD',
                  redirect: 'manual',
                  headers: { 'User-Agent': 'StudentBenefitsHub/1.0 (link checker)' }
                });

                // If HEAD fails with 405, try GET
                if (response.status === 405) {
                  response = await fetch(benefit.link, {
                    method: 'GET',
                    redirect: 'manual',
                    headers: { 'User-Agent': 'StudentBenefitsHub/1.0 (link checker)' }
                  });
                }

                const status = response.status;

                if (status >= 400) {
                  brokenLinks.push({
                    name: benefit.name,
                    link: benefit.link,
                    status: status
                  });
                } else if (status >= 300 && status < 400) {
                  const location = response.headers.get('location');
                  // Check if redirect is to a different domain (potential issue)
                  try {
                    const originalHost = new URL(benefit.link).hostname;
                    const newHost = location ? new URL(location, benefit.link).hostname : null;
                    if (newHost && originalHost !== newHost) {
                      redirectedLinks.push({
                        name: benefit.name,
                        link: benefit.link,
                        redirectTo: location,
                        status: status
                      });
                    }
                  } catch (e) {
                    // URL parsing failed, skip
                  }
                }
              } catch (e) {
                console.log('Error checking', benefit.name, ':', e.message);
                brokenLinks.push({
                  name: benefit.name,
                  link: benefit.link,
                  status: 'Network error: ' + e.message
                });
              }

              // Rate limit
              await new Promise(r => setTimeout(r, 1000));
            }

            console.log('Broken links:', brokenLinks.length);
            console.log('Suspicious redirects:', redirectedLinks.length);

            if (brokenLinks.length === 0 && redirectedLinks.length === 0) {
              console.log('All links healthy!');
              return;
            }

            // Check for existing open issue
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'link-health',
              state: 'open'
            });

            // Build report body
            let body = '## Weekly Link Health Report\n\n';
            body += '_Last checked: ' + new Date().toISOString().split('T')[0] + '_\n\n';

            if (brokenLinks.length > 0) {
              body += '### Broken Links\n\n';
              body += '| Benefit | Link | Status |\n';
              body += '|---------|------|--------|\n';
              for (const b of brokenLinks) {
                body += '| ' + b.name + ' | ' + b.link + ' | ' + b.status + ' |\n';
              }
              body += '\n';
            }

            if (redirectedLinks.length > 0) {
              body += '### Suspicious Redirects\n\n';
              body += '| Benefit | Original | Redirects To |\n';
              body += '|---------|----------|-------------|\n';
              for (const r of redirectedLinks) {
                body += '| ' + r.name + ' | ' + r.link + ' | ' + r.redirectTo + ' |\n';
              }
            }

            if (existingIssues.data.length > 0) {
              const issue = existingIssues.data[0];
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: body
              });
              console.log('Updated existing issue:', issue.html_url);
            } else {
              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: 'Link Health Report: ' + (brokenLinks.length + redirectedLinks.length) + ' issues found',
                body: body,
                labels: ['link-health', 'needs-review']
              });
              console.log('Created issue:', issue.data.html_url);
            }
